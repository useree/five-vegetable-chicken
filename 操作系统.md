## 一. 进程之间究竟有哪些通信方式？

* 1、管道
	- 优点 : 比较简单，能够保证我们的数据已经真的被其他进程拿走了
	- 思路 : 通信方式是单向的，能把第一个命令的输出作为第二个命令的输入, 例如 linux 中的 grep 命令
	- 缺点 : 这种通信方式效率低下 , a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回

* 2、消息队列
	 - 优点 : 把进程的数据放在某个内存之后就马上让进程返回, 无需等待其他进程来取就返回呢
	 - 缺点 : 发送消息（拷贝）这个过程需要花很多时间来读内存

* 3、共享内存
   - 优点 :  解决拷贝所消耗的时间
   - 思路 : 让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中, 完成内存共享机制

* 4、信号量
  - 优点 : 解决多进程竞争内存的问题
  - 思路 : 使用01计数器用来实现进程之间的互斥与同步。

* 5、Socket 
  - 优点 : 实现相隔几千里的进程进行通信, 比如http请求


## 二. 有哪些经典的进程调度算法？
* 1. FCFS
  - 实现 : 所谓 FCFS 就是「先来先服务（First Come First Serve）」，每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，我就会选择队伍最前面的进程，带着他前往 CPU 执行
  - 优点 : 简单又公平
  - 缺点 : 短进程的响应时间太长
* 2. SPN
  - 实现 : 「短任务优先」（Shortest Process Next，SPN）。每次选择预计处理时间最短的进程
  - 优点 : 短进程得到了很好的照顾，进程的平均响应时间大大降低
  - 缺点 : 短进程天天插队，导致长进程经常得不到 CPU 资源，造成了"饥饿"
* 3. HRRN
  - 实现 : 高响应比优先, 综合考量进程的两个属性：等待时间和要求服务时间, 响应比 = （等待时间+要求服务时间）/ 要求服务时间
  - 优点 : 得到了长短进程的一致好评
  - 缺点 : 每次调度前，都要重新计算所有等待进程的响应比
* 4. FCFS
  - 实现 : 所谓 FCFS 就是「先来先服务（First Come First Serve）」，每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，我就会选择队伍最前面的进程，带着他前往 CPU 执行
  - 优点 : 简单又公平
  - 缺点 : 短进程的响应时间太长
* 5. RR
  - 实现 : 时间片轮转算法（Round Robin，RR）
  - 优点 : 看起来十分公平
  - 缺点 : I/O 密集型进程会被频繁插队导致排队时间过长
* 6. VRR
  - 实现 : 「虚拟轮转法」（Virtual Round Robin，VRR）, 为IO密集型进程创建一个新的辅助队列。阻塞解除的进程，将进入这个辅助队列，进行进程调度时，优先选择辅助队列里的进程
  - 优点 : 从实际性能结果来看, 优于轮转法
  - 缺点 : 用户进程太多, 导致操作系统得不到足够的资源
* 7. 优先级调度
  - 实现 : 每个进程将被赋予一个优先级，用户进程的优先级不准高于内核进程的优先级, 为了保证低优先级进程不会饥饿，会调高等待时间长的进程的优先级
  - 优点 : 牛逼
  - 缺点 : 无

## 三. 用户级线程和内核级线程有什么区别？

* 1. 用户级线程
  - 实现 : 对操作系统来说，用户级线程具有不可见性，也称透明性, 如Linux系统中的 pthread（POSIX thread）库
  - 优点 : 应用程序自由定制调度算法, 不受操作系统控制, 线程切换不需要操作系统进行状态转换（从用户态到内核态），开销小
  - 缺点 : 只能一次在一个 CPU 核心上运行, 做不到并行加速

* 2. 内核级线程
  - 实现 : 内核里有用来记录系统里所有线程的线程表。当需要创建一个新线程的时候，就需要进行一个系统调用，然后由操作系统进行线程表的更新
  - 优点 : 可以把这些线程放在好几个 CPU 核心上，做到实际上的并行
  - 缺点 : 内核级线程切换的代价要比用户级线程大, 内核级线程的数量是有限的，扩展性比不上用户级线程






