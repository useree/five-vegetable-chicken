## 一. 进程之间究竟有哪些通信方式？

* 1、管道
	- 优点 : 比较简单，能够保证我们的数据已经真的被其他进程拿走了
	- 思路 : 通信方式是单向的，能把第一个命令的输出作为第二个命令的输入, 例如 linux 中的 grep 命令
	- 缺点 : 这种通信方式效率低下 , a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回

* 2、消息队列
	 - 优点 : 把进程的数据放在某个内存之后就马上让进程返回, 无需等待其他进程来取就返回呢
	 - 缺点 : 发送消息（拷贝）这个过程需要花很多时间来读内存

* 3、共享内存
   - 优点 :  解决拷贝所消耗的时间
   - 思路 : 让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中, 完成内存共享机制

* 4、信号量
  - 优点 : 解决多进程竞争内存的问题
  - 思路 : 使用01计数器用来实现进程之间的互斥与同步。

* 5、Socket 
  - 优点 : 实现相隔几千里的进程进行通信, 比如http请求


## 二. 有哪些经典的进程调度算法？
* 1. FCFS
  - 实现 : 所谓 FCFS 就是「先来先服务（First Come First Serve）」，每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，我就会选择队伍最前面的进程，带着他前往 CPU 执行
  - 优点 : 简单又公平
  - 缺点 : 短进程的响应时间太长
* 2. SPN
  - 实现 : 「短任务优先」（Shortest Process Next，SPN）。每次选择预计处理时间最短的进程
  - 优点 : 短进程得到了很好的照顾，进程的平均响应时间大大降低
  - 缺点 : 短进程天天插队，导致长进程经常得不到 CPU 资源，造成了"饥饿"
* 3. HRRN
  - 实现 : 高响应比优先, 综合考量进程的两个属性：等待时间和要求服务时间, 响应比 = （等待时间+要求服务时间）/ 要求服务时间
  - 优点 : 得到了长短进程的一致好评
  - 缺点 : 每次调度前，都要重新计算所有等待进程的响应比
* 4. FCFS
  - 实现 : 所谓 FCFS 就是「先来先服务（First Come First Serve）」，每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，我就会选择队伍最前面的进程，带着他前往 CPU 执行
  - 优点 : 简单又公平
  - 缺点 : 短进程的响应时间太长
* 5. RR
  - 实现 : 时间片轮转算法（Round Robin，RR）
  - 优点 : 看起来十分公平
  - 缺点 : I/O 密集型进程会被频繁插队导致排队时间过长
* 6. VRR
  - 实现 : 「虚拟轮转法」（Virtual Round Robin，VRR）, 为IO密集型进程创建一个新的辅助队列。阻塞解除的进程，将进入这个辅助队列，进行进程调度时，优先选择辅助队列里的进程
  - 优点 : 从实际性能结果来看, 优于轮转法
  - 缺点 : 用户进程太多, 导致操作系统得不到足够的资源
* 7. 优先级调度
  - 实现 : 每个进程将被赋予一个优先级，用户进程的优先级不准高于内核进程的优先级, 为了保证低优先级进程不会饥饿，会调高等待时间长的进程的优先级
  - 优点 : 牛逼
  - 缺点 : 无

## 三. 用户级线程和内核级线程有什么区别？

* 1. 用户级线程
  - 实现 : 对操作系统来说，用户级线程具有不可见性，也称透明性, 如Linux系统中的 pthread（POSIX thread）库
  - 优点 : 应用程序自由定制调度算法, 不受操作系统控制, 线程切换不需要操作系统进行状态转换（从用户态到内核态），开销小
  - 缺点 : 只能一次在一个 CPU 核心上运行, 做不到并行加速

* 2. 内核级线程
  - 实现 : 内核里有用来记录系统里所有线程的线程表。当需要创建一个新线程的时候，就需要进行一个系统调用，然后由操作系统进行线程表的更新
  - 优点 : 可以把这些线程放在好几个 CPU 核心上，做到实际上的并行
  - 缺点 : 内核级线程切换的代价要比用户级线程大, 内核级线程的数量是有限的，扩展性比不上用户级线程

## 四. 为什么寄存器比内存快？

* 1.  原因一：距离不同
	-  以3GHz的CPU为例，电流每秒钟可以振荡30亿次，每次耗时大约为0.33纳秒。光在1纳秒的时间内，可以前进30厘米。也就是说，在CPU的一个时钟周期内，光可以前进10厘米。因此，如果内存距离CPU超过5厘米，就不可能在一个时钟周期内完成数据的读取，这还没有考虑硬件的限制和电流实际上达不到光速。相比之下，寄存器在CPU内部，当然读起来会快一点
* 2. 原因二：硬件设计不同
	- 内存的设计相对简单，每个位就是一个电容和一个晶体管，而寄存器的设计则完全不同，多出好几个电子元件。并且通电以后，寄存器的晶体管一直有电，而内存的晶体管只有用到的才有电，没用到的就没电，这样有利于省电。这些设计上的因素，决定了寄存器比内存读取速度更快
* 3. 原因三：工作方式不同
	- 寄存器的工作方式很简单，只有两步：
		- （1）找到相关的位
		- （2）读取这些位
	- 内存的工作方式就要复杂得多：
		- （1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）
		- （2）将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。
		- （3）将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。
		- （4）确定数据在哪一个内存块（chunk）上，从该块读取数据。
		- （5）数据先送回内存控制器，再送回CPU，然后开始使用。

